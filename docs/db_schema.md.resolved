# Database Schema Design: Language Learning Assistant

åŸºäºæ–¹æ¡ˆ A (Electron + Python + SQLite)ï¼Œä¸ºäº†æ”¯æŒ Phase 1 (Immersive) å’Œ Phase 2 (Knowledge)ï¼Œæˆ‘ä»¬éœ€è¦è®¾è®¡ä¸€å¥—ä»¥**å†…å®¹**å’Œ**å­¦ä¹ æ•°æ®**ä¸ºæ ¸å¿ƒçš„ Schemaã€‚

**å…³é”®åŸåˆ™**ï¼š
1.  **UUID ä¸»é”®**ï¼šæ‰€æœ‰è¡¨å¼ºåˆ¶ä½¿ç”¨ UUIDï¼Œä¸ºæœªæ¥å¤šç«¯åŒæ­¥ (Phase 4) é“ºè·¯ã€‚
2.  **å†…å®¹ä¸è¿›åº¦åˆ†ç¦»**ï¼šè§†é¢‘å…ƒæ•°æ® (`MediaSource`) ä¸ç”¨æˆ·çš„å­¦ä¹ è¡Œä¸º (`ReviewLog`) åˆ†å¼€ã€‚

---

## ğŸ—ï¸ æ ¸å¿ƒå¯¹è±¡ (Core Entities)

1.  **MediaSource (åª’ä½“æº)**
    *   ä»£è¡¨ä¸€ä¸ªè§†é¢‘æˆ–éŸ³é¢‘æ–‡ä»¶ã€‚
    *   å­˜å‚¨å…ƒæ•°æ®ï¼ˆæ ‡é¢˜ã€æ—¶é•¿ã€æœ¬åœ°è·¯å¾„ã€å°é¢å›¾ï¼‰ã€‚
2.  **SubtitleSegment (å­—å¹•ç‰‡æ®µ)**
    *   ä»£è¡¨åª’ä½“ä¸­çš„ä¸€å¥è¯ã€‚
    *   è¿™æ˜¯**æ ¸å¿ƒäº¤äº’å•å…ƒ**ã€‚ç‚¹å‡»å®ƒè§¦å‘æ’­æ”¾è·³è½¬ï¼›AI é’ˆå¯¹å®ƒç”Ÿæˆè¯­æ³•åˆ†æã€‚
3.  **VocabularyItem (ç”Ÿè¯é¡¹)**
    *   ä»£è¡¨ç”¨æˆ·æ”¶è—çš„ä¸€ä¸ªå•è¯æˆ–çŸ­è¯­ã€‚
    *   **å…³é”®è®¾è®¡**ï¼šä¸ä»…å­˜å•è¯æœ¬èº«ï¼Œè¿˜è¦å­˜**æ¥æºä¸Šä¸‹æ–‡**ï¼ˆå³å‡ºè‡ªå“ªå¥è¯ï¼‰ï¼Œè¿™æ˜¯è¯­è¨€å­¦ä¹ çš„å…³é”®ã€‚
4.  **ReviewLog (å¤ä¹ è®°å½•)**
    *   ä»£è¡¨ SRSï¼ˆé—´éš”é‡å¤ï¼‰çš„å¤ä¹ å†å²ã€‚
    *   è®°å½•â€œæ¯ä¸€æ¬¡â€å¤ä¹ çš„æ—¶é—´ã€è¯„åˆ†ã€ä¸‹æ¬¡å¤ä¹ æ—¶é—´ã€‚
5.  **UserSettings (ç”¨æˆ·è®¾ç½®)**
    *   å•ä¾‹è¡¨ï¼Œå­˜å‚¨å…¨å±€åå¥½ï¼ˆå¦‚ç›®æ ‡è¯­è¨€ã€é»˜è®¤å€é€Ÿã€API Keyï¼‰ã€‚

---

## ğŸ“Š å®ä½“å…³ç³»å›¾ (ER Diagram)

```mermaid
erDiagram
    %% Core Media
    MediaSource ||--|{ SubtitleSegment : "contains"
    
    %% Learning Data
    SubtitleSegment ||--o{ VocabularyItem : "context_for"
    VocabularyItem ||--o{ ReviewLog : "has_history"

    %% DETAILS
    MediaSource {
        uuid id PK
        string title
        string file_path "Local path or URL"
        string source_type "youtube/local"
        string language_code
        float duration
        datetime created_at
        datetime last_played_at
    }

    SubtitleSegment {
        uuid id PK
        uuid media_source_id FK
        float start_time
        float end_time
        text original_text
        text translation
        json grammar_analysis "AI generated JSON"
        int display_index "Order in video"
    }

    VocabularyItem {
        uuid id PK
        uuid source_segment_id FK "Context link"
        string word
        string definition
        string original_sentence_snapshot "Frozen context"
        string audio_clip_path "Optional extracted audio"
        string status "learning/mastered"
        datetime next_review_due "For SRS"
        float srs_interval "Current interval days"
        float srs_ease_factor "SuperMemo-2 factor"
    }
    
    ReviewLog {
        uuid id PK
        uuid vocab_item_id FK
        datetime review_time
        int rating "1-5 score"
    }
```

---

## ğŸ Data Models (Python/SQLModel ä¼ªä»£ç )

```python
from typing import Optional, List
from uuid import UUID, uuid4
from datetime import datetime
from sqlmodel import Field, SQLModel, Relationship

# åŸºç¡€æ¨¡å‹ï¼ŒåŒ…å« UUID
class BaseModel(SQLModel):
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class MediaSource(BaseModel, table=True):
    title: str
    file_path: str  # æœ¬åœ°ç»å¯¹è·¯å¾„ æˆ– URL
    cover_image: Optional[str] = None
    duration: float = 0.0
    language: str = "en"  # åŸæ–‡è¯­è¨€
    
    # å…³è”
    segments: List["SubtitleSegment"] = Relationship(back_populates="media")

class SubtitleSegment(BaseModel, table=True):
    media_id: UUID = Field(foreign_key="mediasource.id")
    index: int  # é¡ºåºç´¢å¼•
    start_time: float
    end_time: float
    text: str
    translation: Optional[str] = None
    
    # AI åˆ†æç»“æœ (å­˜ä¸º JSON å­—ç¬¦ä¸²)
    grammar_notes_json: Optional[str] = None 
    
    # å…³è”
    media: MediaSource = Relationship(back_populates="segments")
    vocabs: List["VocabularyItem"] = Relationship(back_populates="context_segment")

class VocabularyItem(BaseModel, table=True):
    segment_id: Optional[UUID] = Field(foreign_key="subtitlesegment.id")
    
    word: str
    definition: str  # ç”¨æˆ·å¯ç¼–è¾‘çš„é‡Šä¹‰
    
    # ä¸Šä¸‹æ–‡å¿«ç…§ (å³ä½¿åŸè§†é¢‘åˆ äº†ï¼Œè¿™é‡Œä¹Ÿè¦ä¿ç•™ä¾‹å¥)
    sentence_snapshot: str 
    translation_snapshot: str
    
    # SRS ç®—æ³•å­—æ®µ
    status: str = "new"  # new, learning, review, mastered
    ease_factor: float = 2.5
    interval: float = 0.0
    next_review_at: Optional[datetime] = None
    
    # å…³è”
    context_segment: Optional[SubtitleSegment] = Relationship(back_populates="vocabs")
    reviews: List["ReviewLog"] = Relationship(back_populates="vocab")

class ReviewLog(BaseModel, table=True):
    vocab_id: UUID = Field(foreign_key="vocabularyitem.id")
    rating: int  # 1(å¿˜è®°) - 5(å®Œç¾)
    review_date: datetime = Field(default_factory=datetime.utcnow)
    
    # å…³è”
    vocab: VocabularyItem = Relationship(back_populates="reviews")
```

---

### ğŸ’¡ æ ¸å¿ƒè®¾è®¡äº®ç‚¹è§£é‡Š

1.  **`SubtitleSegment` ä½œä¸ºæ¢çº½**ï¼š
    *   ç”¨æˆ·ä¸åªæ˜¯åœ¨â€œèƒŒå•è¯â€ï¼Œè€Œæ˜¯åœ¨â€œé€šè¿‡ä¸Šä¸‹æ–‡èƒŒå•è¯â€ã€‚
    *   æ‰€æœ‰çš„ `VocabularyItem` éƒ½é€šè¿‡ `segment_id` å¼ºå…³è”åˆ°**æŸä¸€å¥å…·ä½“çš„å­—å¹•**ã€‚
    *   è¿™æ ·åœ¨å¤ä¹ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥**æ’­æ”¾é‚£å¥è¯çš„åŸå£°**ï¼Œè€Œä¸åªæ˜¯æ˜¾ç¤ºå†·å†°å†°çš„æ–‡å­—ã€‚

2.  **`sentence_snapshot` (å¿«ç…§ design)**ï¼š
    *   åœ¨ `VocabularyItem` ä¸­ï¼Œæˆ‘é¢å¤–å¢åŠ äº†ä¸€ä¸ª `snapshot` å­—æ®µã€‚
    *   è™½ç„¶æˆ‘ä»¬å…³è”äº† Segmentï¼Œä½†å¦‚æœæœªæ¥ç”¨æˆ·åˆ é™¤äº†é‚£ä¸ªè§†é¢‘ï¼ˆSegment ä¹Ÿæ²¡äº†ï¼‰ï¼Œç”Ÿè¯æœ¬é‡Œçš„å•è¯**ä¸åº”è¯¥æ¶ˆå¤±**ã€‚
    *   æ‰€ä»¥æˆ‘ä»¬åœ¨åˆ›å»ºç”Ÿè¯é‚£ä¸€åˆ»ï¼ŒæŠŠä¾‹å¥**å¤åˆ¶ä¸€ä»½**å­˜è¿›ç”Ÿè¯è¡¨ã€‚è¿™æ˜¯ä¸€ç§**åèŒƒå¼ (Denormalization)** è®¾è®¡ï¼Œä¸ºäº†æ•°æ®å®‰å…¨æ€§å’Œç‹¬ç«‹æ€§ã€‚

3.  **SRS å­—æ®µé¢„åŸ‹**ï¼š
    *   å³ä½¿ Phase 1 æˆ‘ä»¬ä¸åšå¤ä¹ åŠŸèƒ½ï¼Œè¡¨ç»“æ„é‡Œå·²ç»æŠŠ `ease_factor`, `interval`, `next_review_at` ç•™å¥½äº†ã€‚è¿™è®©æœªæ¥çš„ Phase 2 å‡çº§æ— éœ€ä¿®æ”¹æ•°æ®åº“ç»“æ„ã€‚
