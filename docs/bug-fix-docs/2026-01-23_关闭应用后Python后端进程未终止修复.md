# Bug Fix: 关闭应用后 Python 后端进程未终止

## 基本信息

| 项目 | 内容 |
|------|------|
| **发现时间** | 2026-01-21 22:30 (UTC+8) |
| **解决时间** | 2026-01-23 14:48 (UTC+8) |
| **修复耗时** | 约 2 天（跨多个调试会话） |
| **影响范围** | 应用关闭后再次启动时出现 Server Error 500 |
| **严重程度** | 高 |

---

## Bug 描述

### 现象
关闭 LinguaMaster 应用后，Python 后端进程（uvicorn）不会被终止，导致：
1. 端口 8000 持续被占用
2. 再次启动应用时，新的 Electron 连接到旧的后端进程
3. 旧后端可能处于不健康状态，返回 Server Error 500
4. 用户必须手动在任务管理器中终止 Python 进程

### 复现步骤
1. 启动 LinguaMaster 应用
2. 等待后端启动完成，正常使用
3. 点击标题栏 X 按钮关闭应用
4. 打开任务管理器，观察到 `python.exe` 进程仍在运行
5. 再次启动应用，点击任意视频
6. 出现 "Server Error 500" 错误

---

## 根本原因分析

经过多日调试，发现问题有**两层原因**：

### 原因 1: 窗口关闭太快

使用 `frame: false` 创建无边框窗口时，`win.on('close')` 事件触发后窗口会立即关闭。虽然事件处理器中调用了 `killBackend()`，但主进程在同步代码执行完成前就被终止了。

### 原因 2: ESM 模块中 require 不可用

`killBackend()` 函数内部使用动态 `require('child_process')` 导入 `spawnSync`：

```typescript
// 错误的写法
const { spawnSync } = require('child_process')
```

Electron 打包后使用 ESM 模块系统，`require` 函数不可用，导致报错：

```
ReferenceError: require is not defined
```

这导致 `spawnSync` 无法导入，`taskkill` 命令无法执行，Python 进程无法被终止。

---

## 修复方案

### 修复 1: 静态导入 spawnSync

**文件**: `electron/main.ts`

```typescript
// 修改前（第 6 行）
import { spawn, ChildProcess } from 'node:child_process'

// 修改后
import { spawn, spawnSync, ChildProcess } from 'node:child_process'
```

将 `spawnSync` 改为顶部静态导入，避免在函数内部使用 `require`。

### 修复 2: 使用 event.preventDefault() 阻止窗口立即关闭

**文件**: `electron/main.ts`

```typescript
// 添加 isQuitting 标志
let isQuitting = false

// 修改 win.on('close') 事件处理
win.on('close', (event) => {
  // 如果已经在退出过程中，允许关闭
  if (isQuitting) {
    return
  }

  // 阻止窗口立即关闭
  event.preventDefault()

  // 设置退出标志
  isQuitting = true

  // 同步执行进程清理
  killBackend()

  // 清理完成后手动销毁窗口
  if (win) {
    win.destroy()
  }
})
```

通过 `event.preventDefault()` 阻止默认的关闭行为，确保 `killBackend()` 有足够时间执行完成。

### 修复 3: 简化 killBackend() 函数

**文件**: `electron/main.ts`

```typescript
function killBackend(): void {
  if (isBackendKilled) {
    return
  }
  isBackendKilled = true

  if (process.platform !== 'win32') {
    if (pyProcess) {
      pyProcess.kill('SIGKILL')
    }
    return
  }

  // Method 1: Kill by PID
  if (pyProcess && pyProcess.pid) {
    try {
      spawnSync('taskkill', ['/PID', String(pyProcess.pid), '/T', '/F'], {
        timeout: 5000,
        windowsHide: true
      })
    } catch {
      // Ignore errors
    }
  }

  // Method 2: Kill by port 8000 (backup)
  try {
    const netstatResult = spawnSync('cmd.exe',
      ['/c', 'netstat -ano | findstr :8000 | findstr LISTENING'],
      { encoding: 'utf8', timeout: 5000, windowsHide: true, shell: true }
    )
    // ... 解析并终止进程
  } catch {
    // Ignore errors
  }
}
```

使用 `spawnSync` 同步执行 `taskkill`，并添加超时和错误处理。

---

## 技术要点

### 1. Electron ESM 打包后 require 不可用

Electron 使用 Vite 打包时，输出为 ESM 模块格式。ESM 模块中没有 `require` 函数，必须使用 `import` 语法。

**解决方案**: 将所有 `require` 改为顶部 `import`。

### 2. 无边框窗口的关闭行为

使用 `frame: false` 创建无边框窗口时，自定义的关闭按钮通过 IPC 调用 `win.close()`。窗口关闭时触发 `close` 事件，但默认行为是立即关闭窗口。

**解决方案**: 使用 `event.preventDefault()` 阻止默认行为，手动控制关闭流程。

### 3. Windows 进程终止

`spawn()` 使用 `shell: true` 时会创建 cmd.exe 子进程，`pyProcess.pid` 实际指向 cmd.exe 而非 python.exe。需要使用 `/T` 参数终止整个进程树。

---

## 验证步骤

1. 安装新版本 `LinguaMaster Setup 0.1.0.exe`
2. 启动应用，等待后端启动
3. 播放任意视频（确保后端正常工作）
4. 点击标题栏 X 按钮关闭应用
5. 打开任务管理器，确认**没有** python.exe 进程残留
6. 再次启动应用，播放视频
7. 确认**没有** Server Error 500

---

## 相关文件

| 文件 | 修改类型 |
|------|----------|
| `electron/main.ts` | 修改 |
| `package.json` | 修改（版本号 0.0.11 → 0.1.0） |

---

## 后续优化建议

1. **启动时清理旧进程**: `killExistingBackend()` 函数已存在，可作为额外保障在应用启动时清理残留进程

2. **进程监控**: 考虑添加后端进程健康监控，在后端崩溃时自动重启

3. **日志记录**: 在生产环境添加可选的日志记录功能，方便排查问题

4. **单元测试**: 为 `killBackend()` 函数添加测试用例

---

## 调试历程记录

| 日期 | 尝试 | 结果 |
|------|------|------|
| 01-21 | 初步调查，发现进程未终止 | 确认问题 |
| 01-22 | execSync 执行 taskkill | 代码未执行完就退出 |
| 01-22 | 添加文件日志调试 | 发现事件触发但代码中断 |
| 01-23 | spawnSync 替代 execSync | 仍然未执行 |
| 01-23 | event.preventDefault() | 进展！日志继续执行 |
| 01-23 | 发现 `require is not defined` | 定位根因 |
| 01-23 | 静态 import spawnSync | ✅ 成功！ |
