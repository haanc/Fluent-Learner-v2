# 用户体系与订阅支付架构方案 (User & Subscription Architecture)

作为一款**桌面端应用 (Desktop App)**，处理用户和支付的方式与纯网页应用 (Web App) 有显著不同。基于您 "Local First" 的架构基础，我为您设计了三种方案。

---

## 💎 核心产品哲学： "Lazy Auth" (延迟注册)
无论选择哪种技术方案，为了最大化转化率，我强烈建议采用 **"Lazy Auth"** 策略：
1.  **下载即用**：用户安装后无需注册，立即进入“免费模式”使用基础功能。
2.  **价值触发**：当用户点击高级功能（如“AI 深度语法分析”或“云端同步”）时，才弹出“需订阅解锁”的提示。
3.  **无缝升级**：付费/注册后，本地数据自动关联到新账户，无需重新设置。

---

## 🏛️ 方案 A: 现代身份云 (Auth-as-a-Service) - 🥇 推荐方案
**核心理念**：利用成熟的第三方身份服务（如 Supabase Auth / Clerk），像搭建 SaaS 一样搭建桌面应用。

#### 用户体验 (UX)
1.  点击“登录/注册”。
2.  弹出浏览器窗口或应用内 Webview，使用 Google/GitHub 一键登录，或邮箱验证码。
3.  登录成功后，应用获得 Token，解锁功能。

#### 技术实现 (Stack)
*   **Auth Provider**: **Supabase Auth** (推荐，与后续数据库同步完美契合) 或 **Clerk** (UI 更美观)。
*   **Payment**: **LemonSqueezy** 或 **Stripe Checkout**。
*   **流程**：
    1.  应用内集成 `supabase-js` 客户端。
    2.  用户付费后，LemonSqueezy 发送 Webhook 给 Supabase。
    3.  Supabase 更新 `users` 表中的 `subscription_status` 字段。
    4.  桌面端监听 Supabase 用户状态变化，实时解锁功能。

#### 优点
*   **未来兼容性完美**：为 Phase 4 的“多端数据同步”打下直接基础（Supabase 自带 Row Level Security）。
*   **开发极快**：不用自己写登录后端、不用管“忘记密码”、不用存敏感数据。
*   **安全性高**：Token 管理、加密都由专业厂商负责。

#### 缺点
*   需要联网才能进行初始登录验证（登录后可缓存 Token 离线使用）。

---

## 🔑 方案 B: 经典序列号模式 (License Key) - 🥈 传统软件首选
**核心理念**：像 Windows 或 IntelliJ IDEA 那样，只验证“序列号”，不强制维护“用户账户”。

#### 用户体验 (UX)
1.  用户在官网购买，邮箱收到一个 License Key (e.g. `LL-ABCD-1234`).
2.  在软件里点击“激活”，输入 Key。
3.  软件联网验证 Key 有效，写入本地注册表/加密文件，永久解锁。

#### 技术实现 (Stack)
*   **Auth Provider**: **无** (不需要真正的用户系统)。
*   **License Server**: **LemonSqueezy License API** (他们自带发码和验证接口)。
*   **流程**：
    1.  应用内只做一个简单的 HTTP 请求：`POST api.lemonsqueezy.com/v1/licenses/activate`。
    2.  如果返回 `active: true`，本地写入加密的 `license.lic` 文件。
    3.  每次启动时（或定期）静默校验一次。

#### 优点
*   **极度轻量**：根本不需要维护“用户数据库”。
*   **隐私感强**：用户感觉这就是个单机买断软件，不需要交出个人数据。
*   **离线友好**：激活一次后，可以通过算法进行本地离线校验（需配合 RSA 签名）。

#### 缺点
*   **同步困难**：因为没有“账户”概念，未来想做“多端同步”会非常麻烦（怎么知道哪两个电脑是同一个人的？）。
*   **风控难**：容易被破解或 Key 泄露被滥用。

---

## 🛠️ 方案 C: 自建后端 (Self-Hosted) - 🥉 不推荐
**核心理念**：自己用 Python/Node.js 写一套登录注册、发邮件、重置密码的 API。

#### 评价
对于初创产品，这是**最糟糕**的选择。你会把 30% 的精力浪费在造轮子（写邮件服务、做 OAuth 对接、搞 JWT 安全、做支付回调），而不是打磨核心功能。除非你有极特殊且严格的数据合规要求，否则**坚决不要选这个**。

---

## 💡 决策建议

### 功能解锁机制 (Feature Gating)
无论选 A 还是 B，代码层面都需要做一个 **`FeatureManager`** 单例：

```typescript
// 伪代码示例
class FeatureManager {
  isPro() {
    // 方案 A: 检查 Supabase 用户 metadata
    // 方案 B: 检查本地 License 文件签名
    return user.subscription === 'active' || localLicense.isValid();
  }

  canUseAIAnalysis() {
    if (this.isPro()) return true;
    return this.dailyFreeUsage < 5; // 免费用户每天试用5次
  }
}
```

### 最终推荐

如果您确定**未来要做“多端同步”**：
👉 **请坚定选择 方案 A (Supabase Auth)**。
*   理由：它把“身份”和“数据”绑定了。一旦用户登录，不仅能判断由于付费了没有，还能直接拉取他上次存在云端的生词本。

如果您想做**纯买断制单机工具**，不做云同步：
👉 **方案 B (License Key)** 是体验最好的。
*   理由：用户买完输码即用，简单粗暴。
